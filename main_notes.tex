\documentclass[12pt]{amsart}
\usepackage{fullpage,url,mathrsfs,setspace,amssymb}
\usepackage[all]{xy} % for complicated commutative diagrams
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=blue,
    pdftitle={Overleaf Example},
    pdfpagemode=FullScreen,
    }

\usepackage{listings, listings-rust}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
    language=rust,
    aboveskip=3mm,
    belowskip=3mm,
    showstringspaces=false,
    columns=flexible,
    basicstyle={\small\ttfamily},
    numbers=none,
    numberstyle=\tiny\color{gray},
    keywordstyle=\color{blue},
    commentstyle=\color{dkgreen},
    stringstyle=\color{mauve},
    breaklines=true,
    breakatwhitespace=true,
    tabsize=3
}

\usepackage{tikz}
\newcommand{\defi}[1]{\textsf{#1}} % for defined terms
\newtheorem{theorem}{Theorem}
\newtheorem{definition}{Definition}
\newtheorem{example}{Example}
\newtheorem{lemma}{Lemma}
\newtheorem{claim}{Claim}
\newtheorem{conjecture}{Conjecture}
% Characters
\newcommand{\Aff}{{\mathbb A}}
\newcommand{\C}{{\mathbb C}}
\newcommand{\F}{{\mathbb F}}
\newcommand{\G}{{\mathbb G}}
\newcommand{\bbH}{{\mathbb H}}
\newcommand{\PP}{{\mathbb P}}
\newcommand{\Q}{{\mathbb Q}}
\newcommand{\R}{{\mathbb R}}
\newcommand{\Z}{{\mathbb Z}}
\newcommand{\Qbar}{{\overline{\Q}}}
\newcommand{\Zhat}{{\hat{\Z}}}
\newcommand{\Zbar}{{\overline{\Z}}}

\usepackage{graphicx}
\usepackage{amssymb,amsmath}

\setlength\parindent{0pt}
\begin{document}

\title[short paper title]{Rust Programming Course Notes}
\author{David Yang}
\maketitle

\section{Rust Basics}

\begin{lstlisting}[language = Rust]
// fields go in structs
struct Dog {
    breed: String,
    age: u32, // unsigned
}

// methods/functions go in "impl" block
impl Dog {
    fn bark(&self) {
        println!("bark!");
    }
}

// add and max functions
fn add(a: i32, b: i32) -> i32{
    a + b // or "return a + b;"
}

fn max(a: i32, b: i32) -> i32{
    if a > b {
        a
    }
    
    else {
        b
    }
}

fn order(a: i32, b: i32) -> (i32, i32) {
    if a > b { (b, a) } else { (a, b) }
}

fn my_name() -> String {
    "David".to_string()
}

fn main() {
    // print statement
    println!("Hello, world!");
    
    // for loop
    for i in 0..10 {
        println!("i is: {}", i);
    }
    
    // defining immutable int 
    let x: i32 = 0;
    println!("{x}");
    
    // array 
    let arr = [1,2,3,4];
    
    
    // using classes
    let sparky = Dog {
        breed: "Chihuahua".to_string(),
        age: 4,
    };
    
    sparky.bark();
    
    // testing functions
    println!("{}", add(4, 5));
    
    let x: i32 = -5;
    
    // no parentheses around conditionals
    let mut abs: i32 = if x > 0 {
        x
    } else {
        -x
    };
    
    abs += 1;
    
    
}
\end{lstlisting}

\newpage

\section{Memory Management in Rust}

\subsection{Ownership}

\begin{definition}
Rust uses an \textbf{ownership model} to manage memory, with three fundamental rules.
\begin{enumerate}
\item Every value has an owner (variable/struct).
\item Every owner is unique.
\item When the owner goes out of scope, the value is dropped (freed).
\end{enumerate}
\end{definition}

\begin{lstlisting}

fn main() {
    // allocated on the heap
    let string = "Hello".to_string();
    // dropped
} // 'string' goes out of scope, so "Hello" freed


\end{lstlisting}


\begin{lstlisting}
fn say_string(string: String) {
    println!("{}", string);
}

fn main() {
    let string = "Hello".to_string();
    say_string(string);
    // running say_string(string) again would give an error, as the value
    // is used after the move.
} 


\end{lstlisting}

Ownership is checked at compile time. One approach would be to clone the string with string.clone and to then call the function on it. \\

Note that this ownership model \underline{does not} impact ``cheap types" like integers, booleans, and floats.

\subsection{References}
We can use `\&' for references. For example, we could pass a reference to an initial string and call $say_string$ on it just fine.

\begin{lstlisting}
fn say_string(string: &String) {
    println!("{}", string);
}

fn main() {
    let string = "Hello".to_string();
    say_string(&string);
    say_string(&string);
}
\end{lstlisting} 
    
Another example:
\begin{lstlisting}
fn main() { // this is okay, as a loses ownership to b.
    let b;
    {
        let a = "Hello".to_string();
        say_string(&a);
        b = a;
    }
    say_string(&b);
}
\end{lstlisting}

Let's now try to implement a counter.

\begin{lstlisting}
struct Counter {
    count: u32,
}

impl Counter {
    fn get_count(&self) -> u32 {
        self.count
    }

    fn increment(&mut self) {
        self.count += 1
    }
}

fn main() {
    let mut counter = Counter {count : 0}; 
    // mutable reference needs to have mutable ``var'' owner
}
\end{lstlisting}

% Add box around this
\textbf{You can take one mutable reference or as many immutable references as you want at a time (but not both).}

\begin{lstlisting}
    let mut vec: vec![1, 2, 3];
    let first = &vec[0];
    vec.clear(); // mutable reference

    println!("{}", first) // first is an immutable borrow, and we cannot have both at the same time
\end{lstlisting}
\end{document}





